// Code generated by MockGen. DO NOT EDIT.
// Source: interface.go
//
// Generated by this command:
//
//	mockgen -source=interface.go -destination=./mocks/mock_usecase.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	log "github.com/Haevnen/audit-logging-api/internal/entity/log"
	repository "github.com/Haevnen/audit-logging-api/internal/repository"
	gomock "go.uber.org/mock/gomock"
)

// MockCreateLogUseCaseInterface is a mock of CreateLogUseCaseInterface interface.
type MockCreateLogUseCaseInterface struct {
	ctrl     *gomock.Controller
	recorder *MockCreateLogUseCaseInterfaceMockRecorder
	isgomock struct{}
}

// MockCreateLogUseCaseInterfaceMockRecorder is the mock recorder for MockCreateLogUseCaseInterface.
type MockCreateLogUseCaseInterfaceMockRecorder struct {
	mock *MockCreateLogUseCaseInterface
}

// NewMockCreateLogUseCaseInterface creates a new mock instance.
func NewMockCreateLogUseCaseInterface(ctrl *gomock.Controller) *MockCreateLogUseCaseInterface {
	mock := &MockCreateLogUseCaseInterface{ctrl: ctrl}
	mock.recorder = &MockCreateLogUseCaseInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCreateLogUseCaseInterface) EXPECT() *MockCreateLogUseCaseInterfaceMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockCreateLogUseCaseInterface) Execute(ctx context.Context, tenantId, userId string, arg3 log.Log) (*log.Log, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, tenantId, userId, arg3)
	ret0, _ := ret[0].(*log.Log)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockCreateLogUseCaseInterfaceMockRecorder) Execute(ctx, tenantId, userId, arg3 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockCreateLogUseCaseInterface)(nil).Execute), ctx, tenantId, userId, arg3)
}

// ExecuteBulk mocks base method.
func (m *MockCreateLogUseCaseInterface) ExecuteBulk(ctx context.Context, tenantId, userId string, logs []log.Log) ([]log.Log, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteBulk", ctx, tenantId, userId, logs)
	ret0, _ := ret[0].([]log.Log)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteBulk indicates an expected call of ExecuteBulk.
func (mr *MockCreateLogUseCaseInterfaceMockRecorder) ExecuteBulk(ctx, tenantId, userId, logs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteBulk", reflect.TypeOf((*MockCreateLogUseCaseInterface)(nil).ExecuteBulk), ctx, tenantId, userId, logs)
}

// MockGetLogUseCaseInterface is a mock of GetLogUseCaseInterface interface.
type MockGetLogUseCaseInterface struct {
	ctrl     *gomock.Controller
	recorder *MockGetLogUseCaseInterfaceMockRecorder
	isgomock struct{}
}

// MockGetLogUseCaseInterfaceMockRecorder is the mock recorder for MockGetLogUseCaseInterface.
type MockGetLogUseCaseInterfaceMockRecorder struct {
	mock *MockGetLogUseCaseInterface
}

// NewMockGetLogUseCaseInterface creates a new mock instance.
func NewMockGetLogUseCaseInterface(ctrl *gomock.Controller) *MockGetLogUseCaseInterface {
	mock := &MockGetLogUseCaseInterface{ctrl: ctrl}
	mock.recorder = &MockGetLogUseCaseInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetLogUseCaseInterface) EXPECT() *MockGetLogUseCaseInterfaceMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockGetLogUseCaseInterface) Execute(ctx context.Context, id, tenantId string) (*log.Log, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, id, tenantId)
	ret0, _ := ret[0].(*log.Log)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockGetLogUseCaseInterfaceMockRecorder) Execute(ctx, id, tenantId any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetLogUseCaseInterface)(nil).Execute), ctx, id, tenantId)
}

// MockDeleteLogUseCaseInterface is a mock of DeleteLogUseCaseInterface interface.
type MockDeleteLogUseCaseInterface struct {
	ctrl     *gomock.Controller
	recorder *MockDeleteLogUseCaseInterfaceMockRecorder
	isgomock struct{}
}

// MockDeleteLogUseCaseInterfaceMockRecorder is the mock recorder for MockDeleteLogUseCaseInterface.
type MockDeleteLogUseCaseInterfaceMockRecorder struct {
	mock *MockDeleteLogUseCaseInterface
}

// NewMockDeleteLogUseCaseInterface creates a new mock instance.
func NewMockDeleteLogUseCaseInterface(ctrl *gomock.Controller) *MockDeleteLogUseCaseInterface {
	mock := &MockDeleteLogUseCaseInterface{ctrl: ctrl}
	mock.recorder = &MockDeleteLogUseCaseInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeleteLogUseCaseInterface) EXPECT() *MockDeleteLogUseCaseInterfaceMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockDeleteLogUseCaseInterface) Execute(ctx context.Context, tenantId, userId string, beforeDate time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, tenantId, userId, beforeDate)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockDeleteLogUseCaseInterfaceMockRecorder) Execute(ctx, tenantId, userId, beforeDate any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockDeleteLogUseCaseInterface)(nil).Execute), ctx, tenantId, userId, beforeDate)
}

// MockGetStatsUseCaseInterface is a mock of GetStatsUseCaseInterface interface.
type MockGetStatsUseCaseInterface struct {
	ctrl     *gomock.Controller
	recorder *MockGetStatsUseCaseInterfaceMockRecorder
	isgomock struct{}
}

// MockGetStatsUseCaseInterfaceMockRecorder is the mock recorder for MockGetStatsUseCaseInterface.
type MockGetStatsUseCaseInterfaceMockRecorder struct {
	mock *MockGetStatsUseCaseInterface
}

// NewMockGetStatsUseCaseInterface creates a new mock instance.
func NewMockGetStatsUseCaseInterface(ctrl *gomock.Controller) *MockGetStatsUseCaseInterface {
	mock := &MockGetStatsUseCaseInterface{ctrl: ctrl}
	mock.recorder = &MockGetStatsUseCaseInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetStatsUseCaseInterface) EXPECT() *MockGetStatsUseCaseInterfaceMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockGetStatsUseCaseInterface) Execute(ctx context.Context, tenantId string, start, end time.Time) ([]log.LogStats, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, tenantId, start, end)
	ret0, _ := ret[0].([]log.LogStats)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockGetStatsUseCaseInterfaceMockRecorder) Execute(ctx, tenantId, start, end any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetStatsUseCaseInterface)(nil).Execute), ctx, tenantId, start, end)
}

// MockSearchLogsUseCaseInterface is a mock of SearchLogsUseCaseInterface interface.
type MockSearchLogsUseCaseInterface struct {
	ctrl     *gomock.Controller
	recorder *MockSearchLogsUseCaseInterfaceMockRecorder
	isgomock struct{}
}

// MockSearchLogsUseCaseInterfaceMockRecorder is the mock recorder for MockSearchLogsUseCaseInterface.
type MockSearchLogsUseCaseInterfaceMockRecorder struct {
	mock *MockSearchLogsUseCaseInterface
}

// NewMockSearchLogsUseCaseInterface creates a new mock instance.
func NewMockSearchLogsUseCaseInterface(ctrl *gomock.Controller) *MockSearchLogsUseCaseInterface {
	mock := &MockSearchLogsUseCaseInterface{ctrl: ctrl}
	mock.recorder = &MockSearchLogsUseCaseInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSearchLogsUseCaseInterface) EXPECT() *MockSearchLogsUseCaseInterfaceMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockSearchLogsUseCaseInterface) Execute(ctx context.Context, filters repository.LogSearchFilters) (*repository.SearchResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, filters)
	ret0, _ := ret[0].(*repository.SearchResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockSearchLogsUseCaseInterfaceMockRecorder) Execute(ctx, filters any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockSearchLogsUseCaseInterface)(nil).Execute), ctx, filters)
}

// Stream mocks base method.
func (m *MockSearchLogsUseCaseInterface) Stream(ctx context.Context, filters repository.LogSearchFilters, fn func(log.Log) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stream", ctx, filters, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// Stream indicates an expected call of Stream.
func (mr *MockSearchLogsUseCaseInterfaceMockRecorder) Stream(ctx, filters, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stream", reflect.TypeOf((*MockSearchLogsUseCaseInterface)(nil).Stream), ctx, filters, fn)
}
